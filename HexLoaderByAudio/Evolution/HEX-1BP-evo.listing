# File HEX-1BP-evo.asm
0000			;=============================================================================== 
0000			; This loader allows MPF-1B users to load assembled programs (Intel Hex format) 
0000			; into the MPF-1 system memory from a serial link (RS232 or TTL). 
0000			; 
0000			; The serial emitter (usually a computer) is connected to the MPF-1 audio input 
0000			; (EAR) with a specific cable that connects: 
0000			; - the TX serial output of the emitter to the MPF1 EAR center tip 
0000			; - the ground serial output of the emitter to the MPF1 EAR ground. 
0000			; 
0000			; The loader works with both RS232 (typically -12v, +12v but can be less) and 
0000			; TTL serial links (typically 0v, 3.3v or 5v). 
0000			; - RS232 corresponds to DB9 serial port of older PCs. It can also be provided 
0000			;   by USB-RS232 converters outputing a DB9 connector for modern PC 
0000			; - USB-Serial TTL converters are usually used for uploading firmware on modern 
0000			;   embedded systems. They can output either 3.3v or 5v signals. Boths will 
0000			;   work with the Hex loader. 
0000			; 
0000			; Note: This code is an improved version of the HEX-1BP loader from the FLite 
0000			; Electronics LTD company. The original loader only supports RS232 serial links 
0000			; and fails in case a record of type 2 to 5 is encountered in the Intel Hex file. 
0000			; Even if these record types don't apply to the Z80 system, it is not unusual 
0000			; to get such records generated by bin to hex converters. 
0000			; 
0000			; Created by Gotcha 
0000			;=============================================================================== 
0000			 
0000			;  Address of used monitor routines 
0000			monitorReset:	equ 0000h	; Reset 
0000			monitorTone:	equ 05E4h	; Generate sound 
0000			monitorScan:	equ 05FEh	; Scan keyboard and display until a new key-in 
0000			monitorScan1:	equ 0624h 	; Scan keyboard and display one cycle 
0000			monitorAddrDp:	equ 0665h 
0000			 
0000			; Address of used monitor variables 
0000			monitorDISPBF:	equ 1FB6h	; Display buffer 
0000			 
0000			; Variables 
0000			varIsTTL:		equ 1F6Fh	; 80h if TTL, 00h if RS232 
0000			varCRC:			equ 1F70h	; Used to compute the checksum 
0000			varNumBytesInLine:	equ 1F71h	; num bytes in the hex record 
0000			varDataPtr:		equ 1F72h	; address of the load destination (16 bits) 
0000			varOffset:		equ 1F74h	; offset to add to the Intel Hex address (16 bits) 
0000								; to get the actual target address in memory 
0000			varSound:		equ 1F76h	; Sound (beeper) configuration 
0000			 
0000			 
0000			; IO addresses 
0000			io_8255_port_A:	 equ 0000h 
0000			io_8255_port_B:	 equ 0001h 
0000			io_8255_port_C:	 equ 0002h 
0000			 
0000			;------------------ 
0000			; Code 
0000			;------------------ 
0000			 
0000				ORG 2000h 
2000			 
2000			offsetQueryStage: 
2000 dd 21 a1 21		LD          IX,displayOffset 
2004 11 00 00			LD          DE,0x0 
2007 ed 53 74 1f		LD          (varOffset),DE 
200b cd fe 05			CALL        monitorScan			; Display "Offset" & wait for key 
200e cd f0 21			CALL        fEmitSound1 
2011 fe 10			CP          0x10 
2013 30 07			JR          NC,soundQueryStage		; Jump if pressed key is not hexa 
2015									; (no address given by the user) 
2015 cd c7 21			CALL        getAddrFromKeybd 
2018 ed 53 74 1f		LD          (varOffset),DE		; Store the user given offset 
201c			 
201c			soundQueryStage: 
201c dd 21 a7 21		LD          IX,displaySound 
2020 cd fe 05			CALL        monitorScan			; Display "Sound" & wait for key 
2023 21 76 1f			LD          HL,varSound 
2026 36 7f			LD          (HL),0x7f			; Config for port C of 8255: 
2028									; Speaker & LED tone-out = 0 
2028			                                		; --> Sound deactivated 
2028 fe 12			CP          0x12			; Key 'GO' was pressed ? 
202a 28 02			JR          Z,plugQueryStage 
202c 36 ff			LD          (HL),0xff			; Config for port C of 8255: 
202e									; Speaker & LED tone-out = 1 
202e									; --> Sound activated 
202e			 
202e			; Once the user has plugged the cable, we will detect weither we are connected to 
202e			; a RS232 serial port (-V, +V) or to a TTL serial port (0 +V). 
202e			; With this knowledge, we will determine how the bits received should be interpreted 
202e			plugQueryStage: 
202e			 
202e dd 21 ad 21		LD          IX,displayPlug 
2032 cd fe 05			CALL        monitorScan			; Display "Plug" & wait for key 
2035 cd f9 21			CALL        fEmitSound2 
2038 db 00			IN          A,(io_8255_port_A) 
203a cb 7f			BIT         0x7,A	; Bit7=0, then Z=1 if RS232 (tape input = 0v) 
203c							; Bit7=1, then Z=0 if TTL   (tape input = 5v) 
203c 20 08			JR          NZ,isTTL 
203e			 
203e			isRS232: 
203e af				XOR         A				; No change to the input tape 
203f dd 21 b9 21		LD          IX,displayRS232 
2043 c3 4c 20			JP	    plugQueryStageEnd 
2046			 
2046			isTTL: 
2046 3e 80			LD          A,0x80			; Will invert input tape (bit 7) 
2048 dd 21 b3 21		LD          IX,displayTTL 
204c			 
204c			plugQueryStageEnd: 
204c 32 6f 1f			LD	    (varIsTTL),A 
204f 06 64			LD          B,0x64 
2051 cd bf 21			CALL        fDisplayAndLoopBTimes	; Delay of 1s 
2054			 
2054			startTransmissionStage: 
2054 dd 21 89 21		LD          IX,displaySend 
2058 06 64			LD          B,0x64 
205a cd bf 21			CALL        fDisplayAndLoopBTimes	; Delay of 1s 
205d cd f9 21			CALL        fEmitSound2 
2060 3e 40			LD          A,0x40 
2062 d3 01			OUT         (io_8255_port_B),A		; Configure '.' to print on display 
2064 3e ff			LD          A,0xff 
2066 d3 02			OUT         (io_8255_port_C),A		; Print '.' on the display 6 digits 
2068			 
2068			 
2068			;***************************************************** 
2068			; Intel Hex Record handling 
2068			;***************************************************** 
2068			 
2068			handleRecord: 
2068			 
2068			waitForColon: 
2068 cd 55 21			CALL        readCharFromTape 
206b fe 3a			CP          0x3a			; Did we get ':' ? 
206d 20 f9			JR          NZ,waitForColon 
206f			 
206f			getNumBytes: 
206f af				XOR         A 
2070 32 70 1f			LD          (varCRC),A 
2073 cd 28 21			CALL        getByteFromTape 
2076 32 71 1f			LD          (varNumBytesInLine),A 
2079 cd 1e 21			CALL        addAToCRC 
207c			 
207c			getDestAddr: 
207c cd 28 21			CALL        getByteFromTape		; Address higher order byte 
207f cd 1e 21			CALL        addAToCRC 
2082 57				LD          D,A 
2083 cd 28 21			CALL        getByteFromTape		; Address lower order byte 
2086 cd 1e 21			CALL        addAToCRC 
2089 5f				LD          E,A 
208a 2a 74 1f			LD          HL,(varOffset) 
208d 19				ADD         HL,DE 
208e 22 72 1f			LD          (varDataPtr),HL 
2091			 
2091			; Record type handling 
2091			; -------------------- 
2091 cd 28 21			CALL        getByteFromTape		; Type of Intel Hex record 
2094 cd 1e 21			CALL        addAToCRC 
2097 fe 00			CP          0x0				; Data record 
2099 20 06			JR	    NZ,type1 
209b cd cd 20			CALL        fGetDataAndCopy 
209e c3 e6 20			JP	    getAndCheckCRC 
20a1			type1: 
20a1 fe 01			CP          0x1				; End Of File 
20a3 20 06			JR	    NZ,typeOther 
20a5 cd be 20			CALL        fGetDataAndIgnore 
20a8 c3 01 21			JP	    theEndGood 
20ab			 
20ab			typeOther: 
20ab				; For now, we just ignore records of type 2, 3, 4 and 5 since 
20ab				; they don't apply to the Z80 processor 
20ab				; - 2: Extended Segment Address 
20ab				; - 3: Start Segment Address 
20ab				; - 4: Extended Linear Address 
20ab				; - 5: Start Linear Address 
20ab fe 06			CP          0x6 
20ad 38 34			JR          C,ignoreRecordData		; jump if < 6 
20af			 
20af			recordError: 
20af cd 02 22			CALL        fEmitSound3 
20b2 dd 21 8f 21		LD          IX,displayRecord 
20b6 06 64			LD          B,0x64 
20b8 cd bf 21			CALL        fDisplayAndLoopBTimes	; Delay : 100 iterations 
20bb c3 54 20			JP          startTransmissionStage 
20be			 
20be			 
20be			; Record data field 
20be			; -------------------- 
20be			 
20be			fGetDataAndIgnore: 
20be 3a 71 1f			LD          A,(varNumBytesInLine) 
20c1 b7				OR	    A 
20c2 c8				RET	    Z 
20c3			 
20c3 47				LD          B,A 
20c4			fGetDataAndIgnore_loop: 
20c4 cd 28 21			CALL        getByteFromTape 
20c7 cd 1e 21			CALL        addAToCRC			; Compute the CRC 
20ca 10 f8			DJNZ        fGetDataAndIgnore_loop 
20cc c9				RET 
20cd			 
20cd			fGetDataAndCopy: 
20cd 3a 71 1f			LD          A,(varNumBytesInLine) 
20d0 47				LD          B,A 
20d1 dd 2a 72 1f		LD          IX,(varDataPtr) 
20d5			fGetDataAndCopy_loop: 
20d5 cd 28 21			CALL        getByteFromTape 
20d8 dd 77 00			LD          (IX+0x0),A			; Store the read byte in memory 
20db cd 1e 21			CALL        addAToCRC			; Compute the CRC 
20de dd 23			INC         IX 
20e0 10 f3			DJNZ        fGetDataAndCopy_loop 
20e2 c9				RET 
20e3			 
20e3			ignoreRecordData: 
20e3 cd be 20			CALL        fGetDataAndIgnore 
20e6			 
20e6			; End of Record: CRC 
20e6			; -------------------- 
20e6			 
20e6			getAndCheckCRC: 
20e6 cd 28 21			CALL        getByteFromTape 
20e9 21 70 1f			LD          HL,varCRC 
20ec 86				ADD         A,(HL) 
20ed 28 0f			JR          Z,getNextRecord 
20ef			 
20ef			errorCRC: 
20ef cd 02 22			CALL        fEmitSound3 
20f2 dd 21 95 21		LD          IX,displayChecksum 
20f6 06 64			LD          B,0x64 
20f8 cd bf 21			CALL        fDisplayAndLoopBTimes	; Delay: 100 iterations 
20fb c3 54 20			JP          startTransmissionStage 
20fe			 
20fe			getNextRecord: 
20fe c3 68 20			JP          handleRecord 
2101			 
2101			theEndGood: 
2101 cd 0b 22			CALL        fEmitSound4 
2104 dd 21 9b 21		LD          IX,displayGood 
2108 06 64			LD          B,0x64 
210a cd bf 21			CALL        fDisplayAndLoopBTimes	; Delay: 100 iterations 
210d c3 00 00			JP          monitorReset		; Back to monitor 
2110			 
2110			        ;*************************************** 
2110			        ;***        end of program           *** 
2110				;*************************************** 
2110			 
2110			 
2110			;************************************************************************************************ 
2110			;* triggersSoundAndTempoD: 
2110			;* 
2110			;* Beep and turn the tone-out LED if configured in varSound 
2110			;* Loop D times as a delay. 
2110			;************************************************************************************************ 
2110			 
2110			triggersSoundAndTempoD: 
2110 f5				PUSH        AF 
2111 e5				PUSH        HL 
2112 21 76 1f			LD          HL,varSound 
2115 a6				AND         (HL) 
2116 d3 02			OUT         (io_8255_port_C),A	; Beep if configured 
2118			delay_: 
2118 15				DEC         D 
2119 20 fd			JR          NZ,delay_ 
211b e1				POP         HL 
211c f1				POP         AF 
211d c9				RET 
211e			 
211e			;************************************************************************************************ 
211e			;* addAToCRC: 
211e			;* 
211e			;* Add A to the variable that keps the CRC value 
211e			;************************************************************************************************ 
211e			 
211e			addAToCRC: 
211e f5				PUSH        AF 
211f e5				PUSH        HL 
2120 21 70 1f			LD          HL,varCRC 
2123 86				ADD         A,(HL) 
2124 77				LD          (HL),A 
2125 e1				POP         HL 
2126 f1				POP         AF 
2127 c9				RET 
2128			 
2128			;************************************************************************************************ 
2128			;* getByteFromTape: 
2128			;* 
2128			;* Read 2 ASCII characters (representing an hexadecimal byte) from the audio input and return 
2128			;* the corresponding integer value byte in A. 
2128			;************************************************************************************************ 
2128			 
2128			getByteFromTape: 
2128 cd 2f 21			CALL        readAsciiByteIntoHL 
212b cd 38 21			CALL        getByteValueFromHexAscii 
212e c9				RET 
212f			 
212f			 
212f			;************************************************************************************************ 
212f			;* readAsciiByteIntoHL: 
212f			;* 
212f			;* Read 2 ASCII characters from the audio input and return their ASCII code in HL 
212f			;*  - H (1st) 
212f			;*  - L (2nd) 
212f			;************************************************************************************************ 
212f			 
212f			readAsciiByteIntoHL: 
212f cd 55 21			CALL        readCharFromTape 
2132 67				LD          H,A 
2133 cd 55 21			CALL        readCharFromTape 
2136 6f				LD          L,A 
2137 c9				RET 
2138			 
2138			 
2138			;************************************************************************************************ 
2138			;* getByteValueFromHexAscii: 
2138			;* 
2138			;* Take 2 ASCII characters that represent a byte in Hexa (2 nibbles in HL) and return the 
2138			;* corresponding integer value byte in A 
2138			;************************************************************************************************ 
2138			 
2138			getByteValueFromHexAscii: 
2138 7d				LD          A,L 
2139 cd 4b 21			CALL        getHexaValueFromASCII	; LSB 
213c 4f				LD          C,A 
213d 7c				LD          A,H 
213e cd 4b 21			CALL        getHexaValueFromASCII	; MSB 
2141 cb 27			SLA         A 
2143 cb 27			SLA         A 
2145 cb 27			SLA         A 
2147 cb 27			SLA         A 
2149 b1				OR          C 
214a c9				RET 
214b			 
214b			;************************************************************************************************ 
214b			;* getHexaValueFromASCII: 
214b			;* 
214b			;* Compute the integer value of an ASCII character representing a hexa nibble (4 bits). 
214b			;*  - In: A = ASCII code of the nibble 
214b			;*  - out: A = integer value of the nibble 
214b			;************************************************************************************************ 
214b			 
214b			getHexaValueFromASCII: 
214b fe 3a			CP          0x3a 
214d 30 03			JR          NC,isLetter 
214f			 
214f			isNumber: 
214f d6 30			SUB         0x30		; A = valeur du chiffre decimal 
2151 c9				RET 
2152			 
2152			isLetter: 
2152 d6 37			SUB         0x37		; A = valeur de la lettre Hexa 
2154								; (elle doit etre en majuscule) 
2154 c9				RET 
2155			 
2155			;************************************************************************************************ 
2155			;* readCharFromTape: 
2155			;* 
2155			;* Read a 7 bits ASCII character from the audio input 
2155			;* Return its ASCII code in A 
2155			;************************************************************************************************ 
2155			 
2155			readCharFromTape: 
2155 c5				PUSH        BC 
2156 d5				PUSH        DE 
2157 0e 00			LD          C,0x0 
2159 06 08			LD          B,0x8 			; We will read 8 bits after the start bit 
215b 3a 6f 1f			LD	    A,(varIsTTL) 		; Bit interpretation will be inverted for TTL 
215e 5f				LD 	    E,A 
215f			 
215f			waitForTapeInputLow: 
215f db 00			IN          A,(io_8255_port_A)		; Potentially wait for the completion of the 
2161									; previous character 
2161 ab				XOR	    E				; invert A 
2162 cb 7f			BIT         0x7,A 
2164 20 f9			JR          NZ,waitForTapeInputLow 
2166			 
2166			waitForTapeInputHigh: 
2166 db 00			IN          A,(io_8255_port_A)		; Wait for start bit 
2168 ab				XOR	    E				; invert A if TTL 
2169 cb 7f			BIT         0x7,A 
216b 28 f9			JR          Z,waitForTapeInputHigh 
216d 16 35			LD          D,0x35 
216f cd 10 21			CALL        triggersSoundAndTempoD	; Delay of 53 iterations 
2172									; to check: wait until the middle of the next bit transmission 
2172									; ??? ms 
2172			 
2172			getNotBitFromTape: 
2172 db 00			IN          A,(io_8255_port_A) 
2174 ab				XOR	    E				; Invert A if TTL, Flag C = 0 
2175 cb 7f			BIT         0x7,A			; Flag Z = inverse of bit read from audio input 
2177 20 01			JR          NZ,insertBit		; Flag C=0 if Z==0 (when read bit==1 for RS232) 
2179 37				SCF					; Flag C=1 if Z==1 (when read bit==0 for RS232) 
217a			 
217a			insertBit: 
217a cb 19			RR          C				; Rotate right C and inject C as most significant bit 
217c 16 24			LD          D,0x24 
217e cd 10 21			CALL        triggersSoundAndTempoD	; Wait for 36 iterations (next bit) 
2181									; ??? ms 
2181 10 ef			DJNZ        getNotBitFromTape 
2183 cb b9			RES         0x7,C			; Reset the last received bit (parity of stop bit) 
2185 79				LD          A,C 
2186 d1				POP         DE 
2187 c1				POP         BC 
2188 c9				RET 
2189			 
2189			displaySend: 
2189 00				defb           00h	 ;' ' 
218a 00				defb           00h       ;' ' 
218b b3				defb           0B3h      ;'d' 
218c 23				defb           23h       ;'n' 
218d 8f				defb           8Fh       ;'E' 
218e ae				defb           0AEh      ;'S' 
218f			displayRecord: 
218f b3				defb           0B3h      ;'d' 
2190 03				defb           03h       ;'r' 
2191 a3				defb           0A3h      ;'o' 
2192 83				defb           83h       ;'c' 
2193 8f				defb           8Fh       ;'E' 
2194 03				defb           03h       ;'r' 
2195			displayChecksum: 
2195 b5				defb           0B5h      ;'U' 
2196 ae				defb           0AEh      ;'S' 
2197 8d				defb           8Dh       ;'C' 
2198 8f				defb           8Fh       ;'E' 
2199 37				defb           37h       ;'H' 
219a 8d				defb           8Dh       ;'C' 
219b			displayGood: 
219b 00				defb           00h       ;' ' 
219c 00				defb           00h       ;' ' 
219d b3				defb           0B3h      ;'d' 
219e a3				defb           0A3h      ;'o' 
219f a3				defb           0A3h      ;'o' 
21a0 ad				defb           0ADh      ;'G' 
21a1			displayOffset: 
21a1 87				defb           87h       ;'t' 
21a2 8f				defb           8Fh       ;'E' 
21a3 ae				defb           0AEh      ;'S' 
21a4 0f				defb           0Fh       ;'F' 
21a5 0f				defb           0Fh       ;'F' 
21a6 bd				defb           0BDh      ;'O' 
21a7			displaySound: 
21a7 00				defb           00h       ;' ' 
21a8 b3				defb           0B3h      ;'d' 
21a9 23				defb           23h       ;'n' 
21aa a1				defb           0A1h      ;'u' 
21ab a3				defb           0A3h      ;'o' 
21ac ae				defb           0AEh      ;'S' 
21ad			 
21ad			displayPlug: 
21ad 00				defb           00h       ;' ' 
21ae 00				defb           00h       ;' ' 
21af ad				defb           0ADh      ;'g' 
21b0 b5				defb           0B5h      ;'u' 
21b1 85				defb           85h       ;'l' 
21b2 1f				defb           1Fh       ;'P' 
21b3			displayTTL: 
21b3 00				defb           00h       ;' ' 
21b4 00				defb           00h       ;' ' 
21b5 00				defb           00h       ;' ' 
21b6 05				defb           05h       ;'l' 
21b7 87				defb           87h       ;'t' 
21b8 87				defb           87h       ;'t' 
21b9			displayRS232: 
21b9 00				defb           00h       ;' ' 
21ba 9b				defb           9Bh       ;'2' 
21bb ba				defb           0BAh      ;'3' 
21bc 9b				defb           9Bh       ;'2' 
21bd ae				defb           0AEh      ;'s' 
21be 03				defb           03h       ;'r' 
21bf			 
21bf			fDisplayAndLoopBTimes: 
21bf c5				PUSH        BC 
21c0 cd 24 06			CALL        monitorScan1 
21c3 c1				POP         BC 
21c4 10 f9			DJNZ        fDisplayAndLoopBTimes 
21c6 c9				RET 
21c7			 
21c7			;************************************************************************************************ 
21c7			;* getAddrFromKeybd: 
21c7			;* 
21c7			;* Function that read a 16 bit address from the keyboard 
21c7			;* 
21c7			;* The function prints digits on the display as their are entered by the user 
21c7			;* If the user enters more than 4 digit, then only the last 4 are kept. 
21c7			;* 
21c7			;* The function returns as soon as the user pushed a key that is not an hexa digit 
21c7			;* - Input: 
21c7			;*   A: value of the first digit key pressed 
21c7			;* - Output 
21c7			;*   DE: the 2 bytes of the collected address 
21c7			;************************************************************************************************ 
21c7			 
21c7			getAddrFromKeybd: 
21c7 dd 21 b6 1f		LD          IX,monitorDISPBF			; @ of the monitor display buffer (6 bytes) 
21cb 11 00 00			LD          DE,0x0 
21ce ed 53 b6 1f		LD          (monitorDISPBF),DE 
21d2			 
21d2			nextKey: 
21d2 cd e3 21			CALL        shiftL_DE_insert_A_4bits		; Insert the digit of the last key pressed in DE 
21d5 cd 65 06			CALL        monitorAddrDp			; Convert DE (4 nibbles) for the display 
21d8 cd fe 05			CALL        monitorScan 
21db cd f0 21			CALL        fEmitSound1 
21de fe 10			CP          0x10 
21e0 d0				RET         NC 
21e1 18 ef			JR          nextKey 
21e3			 
21e3			 
21e3			shiftL_DE_insert_A_4bits: 
21e3 06 04			LD          B,0x4 
21e5			 
21e5			shift_DE_and_decrement_B: 
21e5 cb 23			SLA         E					; DE = DE << 1 
21e7 cb 12			RL          D 
21e9 10 fa			DJNZ        shift_DE_and_decrement_B		; DE = DE << 1 
21eb			 
21eb e6 0f			AND         0xf 
21ed b3				OR          E 
21ee 5f				LD          E,A 
21ef c9				RET 
21f0			 
21f0			;********************************************************* 
21f0			;* Sound functions 
21f0			;* TODO: determine the frequency 
21f0			;********************************************************* 
21f0			 
21f0			fEmitSound1: 
21f0 c5				PUSH        BC 
21f1 e5				PUSH        HL 
21f2 0e 1e			LD          C,0x1e 
21f4 21 c8 00			LD          HL,0xc8 
21f7 18 1b			JR          call_tone_and_return 
21f9			 
21f9			fEmitSound2: 
21f9 c5				PUSH        BC 
21fa e5				PUSH        HL 
21fb 0e 46			LD          C,0x46 
21fd 21 90 01			LD          HL,0x190 
2200 18 12			JR          call_tone_and_return 
2202			 
2202			fEmitSound3: 
2202 c5				PUSH        BC 
2203 e5				PUSH        HL 
2204 0e c8			LD          C,0xc8 
2206 21 20 03			LD          HL,0x320 
2209 18 09			JR          call_tone_and_return 
220b			 
220b			fEmitSound4: 
220b c5				PUSH        BC 
220c e5				PUSH        HL 
220d 0e 32			LD          C,0x32 
220f 21 58 02			LD          HL,0x258 
2212 18 00			JR          call_tone_and_return 
2214			 
2214			call_tone_and_return: 
2214 f5				PUSH        AF 
2215 d5				PUSH        DE 
2216 cd e4 05			CALL        monitorTone 
2219 d1				POP         DE 
221a f1				POP         AF 
221b e1				POP         HL 
221c c1				POP         BC 
221d c9				RET 
# End of file HEX-1BP-evo.asm
221e
